#从C走进C++

##函数指针

每个函数都会占用一段连续的内存空间。而**函数名就是该函数所占内存区域的起始地址(也称“入口地址”)**。我们可以将函数的入口地址赋给一个指针变量，使该指针变量指向该函数。定义方式如下：
```C++
int (* pf)(int, char)
// int --> 函数指针指向函数的返回值为int
// pf --> 指针变量名
// (int, char) --> 被指向函数接收两个参数，分别为int, char型  
```

##位运算
######用于对整数类型（int,char, long 等）变量中的某一位(bit)，或者若干位进行操作。
```C++
&   按位与(双目)
//只有对应的两个二进位均为1时，结果的对应二进制位才为1，否则为0。
<!-- 
  21 & 18 = 16(即二进制数10000)，因为：
  21 用二进制表示就是：
  0000 0000 0000 0000 0000 0000 0001 0101
  18 用二进制表示就是:
  0000 0000 0000 0000 0000 0000 0001 0010
  二者按位与所得结果是：
  0000 0000 0000 0000 0000 0000 0001 0000
-->
//通常用来将某变量中的某些位清0且同时保留其他位不变。也可以用来获取某变量中的某一位。

|   按位或(双目)
//只有对应的两个二进位都为0时，结果的对应二进制位才是0，否则为1。
//通常用来将某变量中的某些位置1且保留其他位不变。

^   按位异或(双目)
//只有对应的两个二进位不相同时，结果的对应二进制位才是1，否则为0。
//通常用来将某变量中的某些位取反，且保留其他位不变。

~   按位非(取反)(单目)
//是将操作数中的二进制位0变成1，1变成0
<!-- 
	21： 0000 0000 0000 0000 0000 0000 0001 0101
	~21： 1111 1111 1111 1111 1111 1111 1110 1010 
-->

<<  左移(双目)
//将a各二进位全部左移b位后得到的值。左移时，高位丢弃，低位补0。a 的值不因运算而改变。
<!-- 
	9 << 4
	9的二进制形式：
	0000 0000 0000 0000 0000 0000 0000 1001
	因此，表达式“9<<4”的值，就是将上面的二进制数左移4
	位，得：
	0000 0000 0000 0000 0000 0000 1001 0000
	即为十进制的144。
-->
实际上，左移1位，就等于是乘以2，左移n位，就等于
是乘以2^n。而左移操作比乘法操作快得多。

>>  右移(双目)
//将a各二进位全部右移b位后得到的值。右移时，移出最右边的位就被丢弃。 a 的值不因运算而改变。
//实际上，右移n位，就相当于左操作数除以2^n，并且将结果往小里取整。
<!-- 
	-25 >> 4 = -2
	-2 >> 4 = -1
	18 >> 4 = 1 
-->
```

##引用
```C++
	int n = 4;
	int & r = n; // r引用了n, r类型是 int &
	// int & --> 类型名
	// r     --> 引用名
	// n     --> 被引用变量名
```
某个变量的引用，**等价于**这个变量，相当于该变量的一个别名。

* 定义引用时一定要将其初始化成引用某个**变量**。
* 初始化后，它就一直引用该变量，不会再引用别
的变量了。
* 引用只能引用变量，不能引用常量和表达式。

#####引用做函数参数
等价于在操作实参
#####引用做函数返回值
可以对函数调用返回的结果进行赋值。
```C++
int n = 4;
int & SetValue() { return n; }
int main()
{
SetValue() = 40;
cout << n;
return 0;
} // 40
```
####常引用
不能通过常引用去修改其引用的内容:
```C++
int n = 100;
const int & r = n; //类型const int &
r = 200; //编译错
n = 300; // 没问题
```
**const T & 和T & 是不同的类型!!!** 

##动态内存分配
变量


```C++
<!-- 
	P = new T 
	动态分配出一片大小为 sizeof(T)字节的内存空间，并且将该内存空间的起始地址赋值给P。
-->
int * pn;
pn = new int;
// int --> 可替换成任意类型
// pn  --> 对应类型的指针
* pn = 5;
```
数组
```C++
<!-- 
	P = new T[N];
	动态分配出一片大小为 sizeof(T)字节的内存空间，并且	将该内存空间的起始地址赋值给P。
-->
int * pn;
int i = 5;
pn = new int[i * 20];
// N --> 数组元素的个数
pn[0] = 20;
pn[100] = 30; 
delete [] pn;
// 用“new”动态分配的内存空间，一定要用“delete”运算符进行释放, 形式 delete 指针； 、数组 delete [] 指针；
```

##内联函数
函数调用是有时间开销的。如果函数本身只有几条语句，执行非常快，而且函数被反复执行很多次，相比之下调用函数所产生的这个开销就会显得比较大。
为了减少函数调用的开销，引入了内联函数机制。编译器处理对内联函数的调用语句时，是将整个函数的代码插入到调用语句处，而不会产生调用函数的语句。
```C++
inline int Max(int a,int b) {
	if( a > b) return a;
	return b;
}
```

##函数重载
一个或多个函数，名字相同，然而参数个数或参数类型不相同，这叫做函数的重载。
```C++
int Max(double f1,double f2) { }
int Max(int n1,int n2) { }
int Max(int n1,int n2,int n3) { }
```

##缺省参数
C++中，定义函数的时候可以让最右边的连续若干个参数有缺省值，那么调用函数的时候，若相应位置不写参数，参数就是缺省值。
```C++
void func( int x1, int x2 = 2, int x3 = 3) { }
```